// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: identity.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUsers = `-- name: CountUsers :one
SELECT count(*) OVER ()
FROM users u
         JOIN user_team_mapping utm ON u.id = utm.user_id
WHERE utm.team_id IN (SELECT utm_inner.team_id
                      FROM user_team_mapping utm_inner
                               JOIN users u_inner ON utm_inner.user_id = u_inner.id
                      WHERE u_inner.user_id = $1)
`

// Count all users the authorized user can see; used in pagination
func (q *Queries) CountUsers(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTeam = `-- name: CreateTeam :one
SELECT create_team
FROM create_team($1, $2, $3)
`

type CreateTeamParams struct {
	TeamName      string `json:"team_name"`
	TeamEmail     string `json:"team_email"`
	CurrentUserID string `json:"current_user_id"`
}

// Create a team; leverages 'create_team' function which when supplied
// name, email and user_id will either create a team or error on permissions
func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, createTeam, arg.TeamName, arg.TeamEmail, arg.CurrentUserID)
	var create_team interface{}
	err := row.Scan(&create_team)
	return create_team, err
}

const createUserWithNewTeam = `-- name: CreateUserWithNewTeam :one
WITH new_team AS (
    INSERT INTO teams (name, email)
        VALUES ($1, $2)
        RETURNING id,team_id),
     new_user AS (
         INSERT INTO users (username, email, password, verified)
             VALUES ($1, $2, $3, false)
             RETURNING id,user_id),
     new_user_team as (
         INSERT INTO user_team_mapping (user_id, team_id)
             SELECT new_user.id, new_team.id
             FROM new_user,
                  new_team
             RETURNING user_id, team_id)
SELECT new_user.user_id, new_team.team_id
FROM new_user,
     new_team
`

type CreateUserWithNewTeamParams struct {
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

type CreateUserWithNewTeamRow struct {
	UserID string `json:"user_id"`
	TeamID string `json:"team_id"`
}

// Create a new user and a team for them
func (q *Queries) CreateUserWithNewTeam(ctx context.Context, arg CreateUserWithNewTeamParams) (CreateUserWithNewTeamRow, error) {
	row := q.db.QueryRow(ctx, createUserWithNewTeam, arg.Name, arg.Email, arg.Password)
	var i CreateUserWithNewTeamRow
	err := row.Scan(&i.UserID, &i.TeamID)
	return i, err
}

const doesAdminExist = `-- name: DoesAdminExist :one
SELECT EXISTS (SELECT 1
               FROM users u
                        JOIN user_team_mapping utm ON u.id = utm.user_id
               WHERE u.username = 'admin'
                 AND utm.role = 'admin') AS admin_exists
`

// Create admin user (for initial setup only)
func (q *Queries) DoesAdminExist(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, doesAdminExist)
	var admin_exists bool
	err := row.Scan(&admin_exists)
	return admin_exists, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id,
       username,
       email,
       verified,
       created_at,
       updated_at
FROM users
WHERE user_id = $1
`

type GetUserByIDRow struct {
	UserID    string             `json:"user_id"`
	Username  string             `json:"username"`
	Email     string             `json:"email"`
	Verified  bool               `json:"verified"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// Get a user
func (q *Queries) GetUserByID(ctx context.Context, userID string) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i GetUserByIDRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.Verified,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT u.id, u.username, u.email, u.verified, u.created_at, u.updated_at, utm.role
FROM users u
         JOIN user_team_mapping utm ON u.id = utm.user_id
WHERE utm.team_id IN (SELECT utm_inner.team_id
                      FROM user_team_mapping utm_inner
                               JOIN users u_inner ON utm_inner.user_id = u_inner.id
                      WHERE u_inner.user_id = $1)
ORDER BY u.created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsersParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListUsersRow struct {
	ID        int32              `json:"id"`
	Username  string             `json:"username"`
	Email     string             `json:"email"`
	Verified  bool               `json:"verified"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Role      UserRole           `json:"role"`
}

// List all users associated to authorized user and get total count
func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Verified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveUserWithTeamInfoByAPIKEY = `-- name: RetrieveUserWithTeamInfoByAPIKEY :one
SELECT u.id         AS user_pk,
       u.user_id,
       u.username,
       u.email      AS user_email,
       u.verified   AS user_verified,
       u.created_at AS user_created_at,
       u.updated_at AS user_updated_at,
       t.id         AS team_pk,
       t.team_id    AS team_id,
       t.name       AS team_name,
       t.email      AS team_email,
       t.created_at AS team_created_at,
       t.updated_at AS team_updated_at
FROM users u
         JOIN
     user_team_mapping ut ON u.id = ut.user_id
         JOIN
     teams t ON ut.team_id = t.id
WHERE u.api_key = $1
`

type RetrieveUserWithTeamInfoByAPIKEYRow struct {
	UserPk        int32              `json:"user_pk"`
	UserID        string             `json:"user_id"`
	Username      string             `json:"username"`
	UserEmail     string             `json:"user_email"`
	UserVerified  bool               `json:"user_verified"`
	UserCreatedAt pgtype.Timestamptz `json:"user_created_at"`
	UserUpdatedAt pgtype.Timestamptz `json:"user_updated_at"`
	TeamPk        int32              `json:"team_pk"`
	TeamID        string             `json:"team_id"`
	TeamName      string             `json:"team_name"`
	TeamEmail     string             `json:"team_email"`
	TeamCreatedAt pgtype.Timestamptz `json:"team_created_at"`
	TeamUpdatedAt pgtype.Timestamptz `json:"team_updated_at"`
}

// Retrieve user with team info (used in API-KEY auth)
func (q *Queries) RetrieveUserWithTeamInfoByAPIKEY(ctx context.Context, apiKey string) (RetrieveUserWithTeamInfoByAPIKEYRow, error) {
	row := q.db.QueryRow(ctx, retrieveUserWithTeamInfoByAPIKEY, apiKey)
	var i RetrieveUserWithTeamInfoByAPIKEYRow
	err := row.Scan(
		&i.UserPk,
		&i.UserID,
		&i.Username,
		&i.UserEmail,
		&i.UserVerified,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
		&i.TeamPk,
		&i.TeamID,
		&i.TeamName,
		&i.TeamEmail,
		&i.TeamCreatedAt,
		&i.TeamUpdatedAt,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE user_team_mapping
SET role = $1
WHERE user_id = (SELECT id
                 FROM users u
                 WHERE u.user_id = $2)
`

type UpdateUserRoleParams struct {
	Role   UserRole `json:"role"`
	UserID string   `json:"user_id"`
}

// Update a user role
func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserRole, arg.Role, arg.UserID)
	return err
}
